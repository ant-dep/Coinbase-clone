import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export declare type ClaimConditionStruct = {
    startTimestamp: BigNumberish;
    maxClaimableSupply: BigNumberish;
    supplyClaimed: BigNumberish;
    quantityLimitPerTransaction: BigNumberish;
    waitTimeInSecondsBetweenClaims: BigNumberish;
    merkleRoot: BytesLike;
    pricePerToken: BigNumberish;
    currency: string;
};
export declare type ClaimConditionStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    string
] & {
    startTimestamp: BigNumber;
    maxClaimableSupply: BigNumber;
    supplyClaimed: BigNumber;
    quantityLimitPerTransaction: BigNumber;
    waitTimeInSecondsBetweenClaims: BigNumber;
    merkleRoot: string;
    pricePerToken: BigNumber;
    currency: string;
};
export interface ILazyMintERC1155Interface extends utils.Interface {
    functions: {
        "claim(uint256,uint256,bytes32[])": FunctionFragment;
        "lazyMint(uint256,string)": FunctionFragment;
        "nextTokenIdToMint()": FunctionFragment;
        "setClaimConditions(uint256,(uint256,uint256,uint256,uint256,uint256,bytes32,uint256,address)[])": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "claim", values: [BigNumberish, BigNumberish, BytesLike[]]): string;
    encodeFunctionData(functionFragment: "lazyMint", values: [BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "nextTokenIdToMint", values?: undefined): string;
    encodeFunctionData(functionFragment: "setClaimConditions", values: [BigNumberish, ClaimConditionStruct[]]): string;
    decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lazyMint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "nextTokenIdToMint", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setClaimConditions", data: BytesLike): Result;
    events: {
        "ClaimedTokens(uint256,uint256,address,uint256)": EventFragment;
        "LazyMintedTokens(uint256,uint256,string)": EventFragment;
        "NewClaimConditions(uint256,tuple[])": EventFragment;
        "NewOwner(address,address)": EventFragment;
        "NewSaleRecipient(address,uint256,bool)": EventFragment;
        "PrimarySalesFeeUpdates(uint256)": EventFragment;
        "RoyaltyUpdated(uint256)": EventFragment;
        "TransfersRestricted(bool)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "ClaimedTokens"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "LazyMintedTokens"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewClaimConditions"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewOwner"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NewSaleRecipient"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "PrimarySalesFeeUpdates"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoyaltyUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TransfersRestricted"): EventFragment;
}
export declare type ClaimedTokensEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    string,
    BigNumber
], {
    claimConditionIndex: BigNumber;
    tokenId: BigNumber;
    claimer: string;
    quantityClaimed: BigNumber;
}>;
export declare type ClaimedTokensEventFilter = TypedEventFilter<ClaimedTokensEvent>;
export declare type LazyMintedTokensEvent = TypedEvent<[
    BigNumber,
    BigNumber,
    string
], {
    startTokenId: BigNumber;
    endTokenId: BigNumber;
    baseURI: string;
}>;
export declare type LazyMintedTokensEventFilter = TypedEventFilter<LazyMintedTokensEvent>;
export declare type NewClaimConditionsEvent = TypedEvent<[
    BigNumber,
    ClaimConditionStructOutput[]
], {
    tokenId: BigNumber;
    claimConditions: ClaimConditionStructOutput[];
}>;
export declare type NewClaimConditionsEventFilter = TypedEventFilter<NewClaimConditionsEvent>;
export declare type NewOwnerEvent = TypedEvent<[
    string,
    string
], {
    prevOwner: string;
    newOwner: string;
}>;
export declare type NewOwnerEventFilter = TypedEventFilter<NewOwnerEvent>;
export declare type NewSaleRecipientEvent = TypedEvent<[
    string,
    BigNumber,
    boolean
], {
    recipient: string;
    _tokenId: BigNumber;
    isDefaultRecipient: boolean;
}>;
export declare type NewSaleRecipientEventFilter = TypedEventFilter<NewSaleRecipientEvent>;
export declare type PrimarySalesFeeUpdatesEvent = TypedEvent<[
    BigNumber
], {
    newFeeBps: BigNumber;
}>;
export declare type PrimarySalesFeeUpdatesEventFilter = TypedEventFilter<PrimarySalesFeeUpdatesEvent>;
export declare type RoyaltyUpdatedEvent = TypedEvent<[
    BigNumber
], {
    newRoyaltyBps: BigNumber;
}>;
export declare type RoyaltyUpdatedEventFilter = TypedEventFilter<RoyaltyUpdatedEvent>;
export declare type TransfersRestrictedEvent = TypedEvent<[
    boolean
], {
    restricted: boolean;
}>;
export declare type TransfersRestrictedEventFilter = TypedEventFilter<TransfersRestrictedEvent>;
export interface ILazyMintERC1155 extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ILazyMintERC1155Interface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        claim(_tokenId: BigNumberish, _quantity: BigNumberish, _proofs: BytesLike[], overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        lazyMint(_amount: BigNumberish, _baseURIForTokens: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        nextTokenIdToMint(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setClaimConditions(_tokenId: BigNumberish, _conditions: ClaimConditionStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    claim(_tokenId: BigNumberish, _quantity: BigNumberish, _proofs: BytesLike[], overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    lazyMint(_amount: BigNumberish, _baseURIForTokens: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    nextTokenIdToMint(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setClaimConditions(_tokenId: BigNumberish, _conditions: ClaimConditionStruct[], overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        claim(_tokenId: BigNumberish, _quantity: BigNumberish, _proofs: BytesLike[], overrides?: CallOverrides): Promise<void>;
        lazyMint(_amount: BigNumberish, _baseURIForTokens: string, overrides?: CallOverrides): Promise<void>;
        nextTokenIdToMint(overrides?: CallOverrides): Promise<BigNumber>;
        setClaimConditions(_tokenId: BigNumberish, _conditions: ClaimConditionStruct[], overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "ClaimedTokens(uint256,uint256,address,uint256)"(claimConditionIndex?: BigNumberish | null, tokenId?: BigNumberish | null, claimer?: string | null, quantityClaimed?: null): ClaimedTokensEventFilter;
        ClaimedTokens(claimConditionIndex?: BigNumberish | null, tokenId?: BigNumberish | null, claimer?: string | null, quantityClaimed?: null): ClaimedTokensEventFilter;
        "LazyMintedTokens(uint256,uint256,string)"(startTokenId?: null, endTokenId?: null, baseURI?: null): LazyMintedTokensEventFilter;
        LazyMintedTokens(startTokenId?: null, endTokenId?: null, baseURI?: null): LazyMintedTokensEventFilter;
        "NewClaimConditions(uint256,tuple[])"(tokenId?: BigNumberish | null, claimConditions?: null): NewClaimConditionsEventFilter;
        NewClaimConditions(tokenId?: BigNumberish | null, claimConditions?: null): NewClaimConditionsEventFilter;
        "NewOwner(address,address)"(prevOwner?: null, newOwner?: null): NewOwnerEventFilter;
        NewOwner(prevOwner?: null, newOwner?: null): NewOwnerEventFilter;
        "NewSaleRecipient(address,uint256,bool)"(recipient?: string | null, _tokenId?: BigNumberish | null, isDefaultRecipient?: null): NewSaleRecipientEventFilter;
        NewSaleRecipient(recipient?: string | null, _tokenId?: BigNumberish | null, isDefaultRecipient?: null): NewSaleRecipientEventFilter;
        "PrimarySalesFeeUpdates(uint256)"(newFeeBps?: null): PrimarySalesFeeUpdatesEventFilter;
        PrimarySalesFeeUpdates(newFeeBps?: null): PrimarySalesFeeUpdatesEventFilter;
        "RoyaltyUpdated(uint256)"(newRoyaltyBps?: null): RoyaltyUpdatedEventFilter;
        RoyaltyUpdated(newRoyaltyBps?: null): RoyaltyUpdatedEventFilter;
        "TransfersRestricted(bool)"(restricted?: null): TransfersRestrictedEventFilter;
        TransfersRestricted(restricted?: null): TransfersRestrictedEventFilter;
    };
    estimateGas: {
        claim(_tokenId: BigNumberish, _quantity: BigNumberish, _proofs: BytesLike[], overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        lazyMint(_amount: BigNumberish, _baseURIForTokens: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        nextTokenIdToMint(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setClaimConditions(_tokenId: BigNumberish, _conditions: ClaimConditionStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        claim(_tokenId: BigNumberish, _quantity: BigNumberish, _proofs: BytesLike[], overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        lazyMint(_amount: BigNumberish, _baseURIForTokens: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        nextTokenIdToMint(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setClaimConditions(_tokenId: BigNumberish, _conditions: ClaimConditionStruct[], overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
