import { Pack as PackContract } from "@3rdweb/contracts";
import { TransactionReceipt } from "@ethersproject/providers";
import { BigNumber, BigNumberish, BytesLike } from "ethers";
import { CurrencyValue, ModuleType, Role } from "../common";
import { NFTMetadata } from "../common/nft";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
import { ITransferable } from "../interfaces/contracts/ITransferable";
/**
 * @beta
 */
export interface PackMetadata {
    id: string;
    creator: string;
    currentSupply: BigNumber;
    openStart: Date | null;
    metadata: NFTMetadata;
}
/**
 * @public
 */
export interface PackNFTMetadata {
    supply: BigNumber;
    metadata: NFTMetadata;
}
/**
 * @public
 */
export interface PackMetadataWithBalance extends PackMetadata {
    ownedByAddress: BigNumber;
}
export declare enum UnderlyingType {
    None = 0,
    ERC20 = 1,
    ERC721 = 2
}
/**
 * @beta
 */
export interface IPackCreateArgs {
    assetContract: string;
    metadata: MetadataURIOrObject;
    assets: {
        tokenId: BigNumberish;
        amount: BigNumberish;
    }[];
    secondsUntilOpenStart?: BigNumberish;
    rewardsPerOpen?: BigNumberish;
}
/**
 * @beta
 */
export interface IPackBatchArgs {
    tokenId: BigNumberish;
    amount: BigNumberish;
}
/**
 * Create lootboxes of NFTs with rarity based open mechanics.
 *
 * @example
 *
 * ```javascript
 * import { ThirdwebSDK } from "@3rdweb/sdk";
 *
 * // You can switch out this provider with any wallet or provider setup you like.
 * const provider = ethers.Wallet.createRandom();
 * const sdk = new ThirdwebSDK(provider);
 * const module = sdk.getPackModule("{{module_address}}");
 * ```
 *
 * @public
 */
export declare class PackModule extends ModuleWithRoles<PackContract> implements ITransferable {
    static moduleType: ModuleType;
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    /**
     * @override
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    protected connectContract(): PackContract;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    /**
     * Open Pack
     *
     * @remarks Open a pack to burn it and obtain the reward asset inside.
     *
     * @example
     * ```javascript
     * // The pack ID of the asset you want to buy
     * const packId = "0";
     * const rewards = await module.open(packId);
     * console.log(rewards);
     * ```
     */
    open(packId: string): Promise<NFTMetadata[]>;
    get(packId: string): Promise<PackMetadata>;
    /**
     * Get Pack Data
     *
     * @remarks Get data associated with every pack in this module.
     *
     * @example
     * ```javascript
     * const packs = await module.getAll();
     * console.log(packs);
     * ```
     *
     * @returns The NFT metadata for all NFTs in the module.
     */
    getAll(): Promise<PackMetadata[]>;
    /**
     * Get Pack Reward Data
     *
     * @remarks Get data associated with the rewards inside a specified pack
     *
     * @example
     * ```javascript
     * // The pack ID of the pack whos rewards you want to get
     * const packId = 0;
     *
     * const nfts = await module.getNFTs(packId);
     * console.log(nfts);
     * ```
     *
     * @returns The NFT metadata for all NFTs in the module.
     */
    getNFTs(packId: string): Promise<PackNFTMetadata[]>;
    /**
     * Get Pack Balance
     *
     * @remarks Get a wallets pack balance (number of a specific packs in this module owned by the wallet).
     *
     * @example
     * ```javascript
     * // Address of the wallet to check pack balance
     * const address = "{{wallet_address}}"";
     * // The token ID of the pack you want to check the wallets balance of
     * const tokenId = "0"
     *
     * const balance = await module.balanceOf(address, tokenId);
     * console.log(balance);
     * ```
     */
    balanceOf(address: string, tokenId: string): Promise<BigNumber>;
    balance(tokenId: string): Promise<BigNumber>;
    isApproved(address: string, operator: string): Promise<boolean>;
    setApproval(operator: string, approved?: boolean): Promise<void>;
    /**
     * Transfer Pack
     *
     * @remarks Transfer a pack from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the pack to
     * const toAddress = "0x...";
     *
     * // The token ID of the pack you want to send
     * const tokenId = "0";
     *
     * // The number of packs you want to send
     * const amount = 1;
     *
     * await module.transfer(toAddress, tokenId, amount);
     * ```
     */
    transfer(to: string, tokenId: string, amount: BigNumber): Promise<void>;
    /**
     * Create Pack
     *
     * @remarks Create a new pack with its own rewards.
     *
     * @example
     * ```javascript
     * // Data to create the pack
     * const pack = {
     *   // The address of the contract that holds the rewards you want to include
     *   assetContract: "0x...",
     *   // The metadata of the pack
     *   metadata: {
     *     name: "Cool Pack",
     *     description: "This is a cool pack",
     *     // This can be an image url or image file
     *     image: readFileSync("path/to/image.png"),
     *   },
     *   // The NFTs you want to include in the pack
     *   assets: [
     *     {
     *       tokenId: 0, // The token ID of the asset you want to add
     *       amount: 1, // The amount of the asset you want to add
     *     }, {
     *       tokenId: 1,
     *       amount: 1,
     *     }
     *   ],
     * };
     *
     * await module.create(pack);
     * ```
     *
     * @param args - Args for the pack creation
     * @returns - The newly created pack metadata
     */
    create(args: IPackCreateArgs): Promise<PackMetadata>;
    transferFrom(from: string, to: string, args: IPackBatchArgs, data?: BytesLike): Promise<void>;
    transferBatchFrom(from: string, to: string, args: IPackBatchArgs[], data?: BytesLike): Promise<void>;
    getLinkBalance(): Promise<CurrencyValue>;
    depositLink(amount: BigNumberish): Promise<void>;
    withdrawLink(to: string, amount: BigNumberish): Promise<void>;
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<void>;
    /**
     * Gets the royalty BPS (basis points) of the contract
     *
     * @returns - The royalty BPS
     */
    getRoyaltyBps(): Promise<BigNumberish>;
    /**
     * Gets the address of the royalty recipient
     *
     * @returns - The royalty BPS
     */
    getRoyaltyRecipientAddress(): Promise<string>;
    isTransferRestricted(): Promise<boolean>;
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
    /**
     * `getOwned` is a convenience method for getting all owned tokens
     * for a particular wallet.
     *
     * @param _address - The address to check for token ownership
     * @returns An array of PackMetadataWithBalance objects that are owned by the address
     */
    getOwned(_address?: string): Promise<PackMetadataWithBalance[]>;
}
