import { NFTCollection as NFTBundleContract } from "@3rdweb/contracts";
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";
import { TransactionReceipt } from "@ethersproject/providers";
import { BytesLike } from "ethers";
import { ModuleType, Role } from "../common";
import { NFTMetadata } from "../common/nft";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
import { ITransferable } from "../interfaces/contracts/ITransferable";
import { UnderlyingType } from "./pack";
/**
 * @beta
 */
export interface BundleMetadata {
    creator: string;
    supply: BigNumber;
    metadata: NFTMetadata;
    ownedByAddress: BigNumber;
    underlyingType: UnderlyingType;
}
export interface CollectionMetadata {
    creator: string;
    supply: BigNumber;
    metadata: NFTMetadata;
    ownedByAddress: BigNumber;
}
/**
 * @beta
 */
export interface INFTBundleCreateArgs {
    metadata: MetadataURIOrObject;
    supply: BigNumberish;
}
export interface INFTCollectionCreateArgs {
    metadata: MetadataURIOrObject;
    supply: BigNumberish;
}
/**
 * @beta
 */
export interface INFTCollectionBatchArgs {
    tokenId: BigNumberish;
    amount: BigNumberish;
}
export interface INFTBundleBatchArgs {
    tokenId: BigNumberish;
    amount: BigNumberish;
}
/**
 * Create a collection of NFTs that lets you optionally mint multiple copies of each NFT.
 *
 * @example
 *
 * ```javascript
 * import { ThirdwebSDK } from "@3rdweb/sdk";
 *
 * // You can switch out this provider with any wallet or provider setup you like.
 * const provider = ethers.Wallet.createRandom();
 * const sdk = new ThirdwebSDK(provider);
 * const module = sdk.getBundleModule("{{module_address}}");
 * ```
 *
 * @public
 */
export declare class BundleModule extends ModuleWithRoles<NFTBundleContract> implements ITransferable {
    static moduleType: ModuleType;
    static roles: readonly ["admin", "minter", "pauser", "transfer"];
    /**
     * @override
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    protected connectContract(): NFTBundleContract;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    /**
     *
     * Get a single bundle item by tokenId.
     * @param tokenId - the unique token id of the nft
     * @returns A promise that resolves to a `BundleMetadata`.
     */
    get(tokenId: string, address?: string): Promise<BundleMetadata>;
    /**
     * Get NFT Data
     *
     * @remarks Get data associated with NFTs in this module.
     *
     * @example
     * ```javascript
     * // You can get every NFT in the module
     * const nfts = await module.getAll();
     * console.log(nfts);
     *
     * // Or you can get optionally get the NFTs owned by a specific wallet
     * const address = "{{wallet_address}}"; // The address you want to get the NFTs for;
     * const ownedNfts = await module.getAll(address);
     * console.log(ownedNfts);
     * ```
     *
     * @returns The NFT metadata for all NFTs in the module.
     */
    getAll(address?: string): Promise<BundleMetadata[]>;
    /**
     * Get NFT Balance
     *
     * @remarks Get a wallets NFT balance (number of a specific NFT in this module owned by the wallet).
     *
     * @example
     * ```javascript
     * // Address of the wallet to check NFT balance
     * const address = "{{wallet_address}}";
     * // The token ID of the NFT you want to check the wallets balance of
     * const tokenId = "0"
     *
     * const balance = await module.balanceOf(address, tokenId);
     * console.log(balance);
     * ```
     */
    balanceOf(address: string, tokenId: string): Promise<BigNumber>;
    balance(tokenId: string): Promise<BigNumber>;
    isApproved(address: string, operator: string, assetContract?: string, assetId?: BigNumberish): Promise<boolean>;
    setApproval(operator: string, approved?: boolean): Promise<TransactionReceipt>;
    /**
     * Transfer NFT
     *
     * @remarks Transfer an NFT from the connected wallet to another wallet.
     *
     * @example
     * ```javascript
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "0x...";
     *
     * // The token ID of the NFT you want to send
     * const tokenId = "0";
     *
     * // The number of NFTs you want to send
     * const amount = 1;
     *
     * await module.transfer(toAddress, tokenId, amount);
     * ```
     */
    transfer(to: string, tokenId: string, amount: BigNumberish): Promise<TransactionReceipt>;
    create(metadata: MetadataURIOrObject): Promise<BundleMetadata>;
    createBatch(metadatas: MetadataURIOrObject[]): Promise<BundleMetadata[]>;
    /**
     * Mint NFT
     *
     * @remarks Mint an NFT with a specified supply.
     *
     * @example
     * ```javascript
     * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.
     * const metadata = {
     *   name: "Cool NFT",
     *   description: "This is a cool NFT",
     *   image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     * }
     *
     * const metadataWithSupply = {
     *   metadata,
     *   supply: 1, // The number of this NFT you want to mint
     * }
     *
     * await module.createAndMint(metadataWithSupply);
     * ```
     */
    createAndMint(metadataWithSupply: INFTBundleCreateArgs): Promise<BundleMetadata>;
    /**
     * Mint Many NFTs
     *
     * @remarks Mint many different NFTs with specified supplies.
     *
     * @example
     * ```javascript
     * // Custom metadata and supplies of your NFTs
     * const metadataWithSupply = [{
     *   supply: 1, // The number of this NFT you want to mint
     *   metadata: {
     *     name: "Cool NFT #1",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }, {
     *   supply: 1,
     *   metadata: {
     *     name: "Cool NFT #2",
     *     description: "This is a cool NFT",
     *     image: fs.readFileSync("path/to/image.png"), // This can be an image url or file
     *   },
     * }];
     *
     * await module.createAndMintBatch(metadataWithSupply);
     * ```
     */
    createAndMintBatch(metadataWithSupply: INFTBundleCreateArgs[]): Promise<BundleMetadata[]>;
    createWithToken(tokenContract: string, tokenAmount: BigNumberish, args: INFTBundleCreateArgs): Promise<void>;
    createWithErc20(tokenContract: string, tokenAmount: BigNumberish, args: INFTBundleCreateArgs): Promise<void>;
    createWithNFT(tokenContract: string, tokenId: BigNumberish, metadata: MetadataURIOrObject): Promise<void>;
    unwrapNFT(tokenId: BigNumberish): Promise<TransactionReceipt>;
    unwrapToken(tokenId: BigNumberish, amount: BigNumberish): Promise<TransactionReceipt>;
    createWithERC721(tokenContract: string, tokenId: BigNumberish, metadata: MetadataURIOrObject): Promise<void>;
    mint(args: INFTBundleBatchArgs): Promise<void>;
    mintTo(to: string, args: INFTBundleBatchArgs, data?: BytesLike): Promise<void>;
    mintBatch(args: INFTBundleBatchArgs[]): Promise<void>;
    mintBatchTo(to: string, args: INFTBundleBatchArgs[], data?: BytesLike): Promise<void>;
    /**
     * Burn NFT
     *
     * @remarks Burn an NFT, permanently taking it out of circulation and reducing the supply.
     *
     * @example
     * ```javascript
     * // The token ID of the NFT you want to burn
     * const tokenId = 0;
     * // The number of specified NFTs you want to burn
     * const amount = 1
     *
     * await module.burn({ tokenId, amount });
     * ```
     */
    burn(args: INFTBundleBatchArgs): Promise<TransactionReceipt>;
    burnBatch(args: INFTBundleBatchArgs[]): Promise<TransactionReceipt>;
    burnFrom(account: string, args: INFTBundleBatchArgs): Promise<TransactionReceipt>;
    burnBatchFrom(account: string, args: INFTBundleBatchArgs[]): Promise<TransactionReceipt>;
    transferFrom(from: string, to: string, args: INFTBundleBatchArgs, data?: BytesLike): Promise<TransactionReceipt>;
    /**
     * Transfer Many NFTs
     *
     * @remarks Transfer NFTs from the one wallet to another.
     *
     * @example
     * ```javascript
     * // Address of the wallet to send the NFT from
     * const fromAddress = "{{wallet_address}}";
     * // Address of the wallet you want to send the NFT to
     * const toAddress = "0x...";
     *
     * // The data of the NFTs you want to send
     * const data = [{
     *   tokenId: 1, // The token ID of the NFT you want to send
     *   amount: 1, // The number of this NFT you want to send
     * }, {
     *   tokenId: 2,
     *   amount: 1,
     * }]
     *
     * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress
     * await module.transferBatchFrom(fromAddress, toAddress, data);
     * ```
     */
    transferBatchFrom(from: string, to: string, args: INFTBundleBatchArgs[], data?: BytesLike): Promise<TransactionReceipt>;
    setRoyaltyBps(amount: number): Promise<TransactionReceipt>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    /**
     * `getOwned` is a convenience method for getting all owned tokens
     * for a particular wallet.
     *
     * @param _address - The address to check for token ownership
     * @returns An array of BundleMetadata objects that are owned by the address
     */
    getOwned(_address?: string): Promise<BundleMetadata[]>;
    /**
     * Gets the royalty BPS (basis points) of the contract
     *
     * @returns - The royalty BPS
     */
    getRoyaltyBps(): Promise<BigNumberish>;
    /**
     * Gets the address of the royalty recipient
     *
     * @returns - The royalty BPS
     */
    getRoyaltyRecipientAddress(): Promise<string>;
    isTransferRestricted(): Promise<boolean>;
    setRestrictedTransfer(restricted?: boolean): Promise<TransactionReceipt>;
}
