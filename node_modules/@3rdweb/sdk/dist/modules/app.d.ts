import { ProtocolControl } from "@3rdweb/contracts";
import { TransactionReceipt } from "@ethersproject/providers";
import { BigNumber } from "ethers";
import { CurrencyValue, Role } from "../common";
import { ModuleType } from "../common/module-type";
import { ModuleWithRoles } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
import IAppModule from "../interfaces/IAppModule";
import { BundleDropModuleMetadata, BundleModuleMetadata, CurrencyModuleMetadata, DatastoreModuleMetadata, DropModuleMetadata, MarketModuleMetadata, NewSplitRecipient, NftModuleMetadata, PackModuleMetadata, SplitsModuleMetadata, TokenModuleMetadata, VoteModuleMetadata } from "../types/module-deployments";
import MarketplaceModuleMetadata from "../types/module-deployments/MarketplaceModuleMetadata";
import { ModuleMetadata, ModuleMetadataNoType } from "../types/ModuleMetadata";
import { BundleDropModule } from "./bundleDrop";
import { CollectionModule } from "./collection";
import { DatastoreModule } from "./datastore";
import { DropModule } from "./drop";
import { MarketModule } from "./market";
import { MarketplaceModule } from "./marketplace";
import { NFTModule } from "./nft";
import { PackModule } from "./pack";
import { SplitsModule } from "./royalty";
import { CurrencyModule, TokenModule } from "./token";
import { VoteModule } from "./vote";
/**
 * Access this module by calling {@link ThirdwebSDK.getAppModule}
 * @public
 */
export declare class AppModule extends ModuleWithRoles<ProtocolControl> implements IAppModule {
    private _shouldCheckVersion;
    private _isV1;
    private jsonConvert;
    static roles: readonly ["admin"];
    /**
     * @override
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * The internal module type for the app module.
     * We do not treat it as a fully fledged module on the contract level, so it does not have a real type.
     * @internal
     * @readonly
     */
    private moduleType;
    /**
     * @internal
     */
    protected connectContract(): ProtocolControl;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    /**
     * @internal
     *
     */
    private getModuleAddress;
    private getNFTAddress;
    private getBundleAddress;
    private getPackAddress;
    private getCurrencyAddress;
    private getMarketAddress;
    private getDropAddress;
    private getDatastoreAddress;
    getRoyaltyTreasury(address?: string): Promise<string>;
    /**
     * @internal
     * @param addresses - The addresses of the modules to get metadata for.
     */
    getAllContractMetadata(addresses: string[], resolveGateway?: boolean): Promise<ModuleMetadataNoType[]>;
    /**
     * Method to get a list of pack module metadata.
     * @returns A promise of an array of Pack modules.
     * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead
     */
    getPackModules(): Promise<ModuleMetadata[]>;
    /**
     * Method to get a list of NFT module metadata.
     * @returns A promise of an array of NFT modules.
     * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead
     */
    getNFTModules(): Promise<ModuleMetadata[]>;
    /**
     * Method to get a list of Bundle module metadata.
     * @returns A promise of an array of Bundle modules.
     * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead
     */
    getCollectionModules(): Promise<ModuleMetadata[]>;
    getBundleModules(): Promise<ModuleMetadata[]>;
    /**
     * Method to get a list of Currency module metadata.
     * @returns A promise of an array of Currency modules.
     * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead
     */
    getCurrencyModules(): Promise<ModuleMetadata[]>;
    /**
     * Method to get a list of Datastore module metadata.
     * @alpha
     * @returns A promise of an array of Datastore modules.
     * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead
     */
    getDatastoreModules(): Promise<ModuleMetadata[]>;
    /**
     * Method to get a list of Market module metadata.
     * @returns A promise of an array of Market modules.
     * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead
     */
    getMarketModules(): Promise<ModuleMetadata[]>;
    /**
     * Method to get a list of Drop module metadata.
     * @returns A promise of an array of Drop modules.
     * @deprecated - Use {@link AppModule.getAllModuleMetadata} instead
     */
    getDropModules(): Promise<ModuleMetadata[]>;
    /**
     * Method to get a list of all module metadata on a given app.
     * @public
     * @param filterByModuleType - Optional array of {@link ModuleType} to filter by.
     * @returns Array of module metadata
     */
    getAllModuleMetadata(filterByModuleType?: ModuleType[], resolveGateway?: boolean): Promise<ModuleMetadata[]>;
    /**
     * Trusted forwarder is used to forward gasless transactions. Trusted Forwarder of each module cannot be changed once it is deployed.
     *
     * @returns The address of the trusted forwarder contract
     */
    getForwarder(): Promise<string>;
    /**
     * Set trusted forwarder for the modules. Every module that is deployed after this call will use the new forwarder.
     * Trusted forwarder is used to forward gasless transactions. Trusted Forwarder of each module cannot be changed once it is deployed.
     *
     * @param address - The address of the trusted forwarder contract
     */
    setForwarder(address: string): Promise<void>;
    /**
     * @deprecated - Use setMetadata() instead
     */
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    setRoyaltyTreasury(treasury: string): Promise<TransactionReceipt>;
    setModuleRoyaltyTreasury(moduleAddress: string, treasury: string): Promise<TransactionReceipt>;
    /**
     * Checks to see if an address is either the current protocol
     * control address, or a splits module address.
     *
     * @internal
     * @param address - The address to check.
     * @returns - True if the address is of this protocol control or if its a split module.
     */
    private isValidRoyaltyRecipient;
    withdrawFunds(to: string, currency: string): Promise<TransactionReceipt>;
    /**
     * Helper method that handles `image` property uploads if its a file
     *
     * @param metadata - The metadata of the module to be deployed
     * @returns - The sanitized metadata with an uploaded image ipfs hash
     */
    private _prepareMetadata;
    /**
     * Helper method that deploys a module and returns its address
     *
     * @internal
     *
     * @param moduleType - The ModuleType to deploy
     * @param args - Constructor arguments for the module
     * @param factory - The ABI factory used to call the `deploy` method
     * @returns The address of the deployed module
     */
    private _deployModule;
    /**
     * Throws an error if metadata is invalid
     *
     * @param metadata - The metadata to validate
     */
    private verifyMetadata;
    /**
     * Deploys a collection module.
     *
     * @param metadata - Metadata about the module.
     * @returns A promise with the newly created module.
     */
    deployBundleModule(metadata: BundleModuleMetadata): Promise<CollectionModule>;
    /**
     * Deploys a Splits module
     *
     * @param metadata - The module metadata
     * @returns - The deployed splits module
     */
    deploySplitsModule(metadata: SplitsModuleMetadata): Promise<SplitsModule>;
    /**
     * Deploys a NFT module.
     *
     * @param metadata - The module metadata
     * @returns - The deployed NFT module
     */
    deployNftModule(metadata: NftModuleMetadata): Promise<NFTModule>;
    /**
     * Deploys a currency module.
     *
     * @param metadata - The module metadata
     * @returns - The deployed currency module
     */
    deployCurrencyModule(metadata: CurrencyModuleMetadata): Promise<CurrencyModule>;
    /**
     * Deploys a token module.
     *
     * @param metadata - The module metadata
     * @returns - The deployed currency module
     */
    deployTokenModule(metadata: TokenModuleMetadata): Promise<TokenModule>;
    /**
     * Deploys a Marketplace module
     *
     * @param metadata - The module metadata
     * @returns - The deployed Marketplace module
     */
    deployMarketModule(metadata: MarketModuleMetadata): Promise<MarketModule>;
    /**
     * Deploys a Pack module
     *
     * @param metadata - The module metadata
     * @returns - The deployed Pack module
     */
    deployPackModule(metadata: PackModuleMetadata): Promise<PackModule>;
    /**
     * Deploys a Drop module
     *
     * @param metadata - The module metadata
     * @returns - The deployed Drop module
     */
    deployDropModule(metadata: DropModuleMetadata): Promise<DropModule>;
    /**
     * Deploys a Bundle Drop module
     *
     * @param metadata - The module metadata
     * @returns - The deployed Bundle Drop module
     */
    deployBundleDropModule(metadata: BundleDropModuleMetadata): Promise<BundleDropModule>;
    /**
     * Deploys a Datastore module
     *
     * @alpha
     * @param metadata - The module metadata
     * @returns - The deployed Datastore module
     */
    deployDatastoreModule(metadata: DatastoreModuleMetadata): Promise<DatastoreModule>;
    /**
     * Deploys a Vote module
     *
     * @param metadata - The module metadata
     * @returns - The deployed vote module
     */
    deployVoteModule(metadata: VoteModuleMetadata): Promise<VoteModule>;
    shouldUpgradeToV2(): Promise<boolean>;
    shouldUpgradeModuleList(): Promise<ModuleMetadata[]>;
    /**
     * @internal
     */
    upgradeModuleList(moduleAddresses: string[]): Promise<TransactionReceipt[]>;
    /**
     *  @internal
     * Upgrades the protocol control to v2. In v2, the royalty treasury needs to be set to be set to a splits contract.
     *
     * @param splitsModuleAddress - Optional. By default, it automatically creates a Splits for the project.
     * @param splitsRecipients - Optiional. By default, it is the signer who upgrades.
     */
    upgradeToV2(upgradeOptions?: {
        splitsModuleAddress?: string;
        splitsRecipients?: NewSplitRecipient[];
    }): Promise<TransactionReceipt | undefined>;
    /**
     * Check the balance of the project wallet in the native token of the chain
     *
     * @returns - The balance of the project in the native token of the chain
     */
    balance(): Promise<BigNumber>;
    /**
     * Check the balance of the project wallet in a particular
     * ERC20 token contract
     *
     * @returns - The balance of the project in the native token of the chain
     */
    balanceOfToken(tokenAddress: string): Promise<CurrencyValue>;
    /**
     * @internal
     * Check if contract is v1 or v2. If the contract doesn't have version = v1 contract.
     */
    isV1(): Promise<boolean>;
    /**
     * @internal
     */
    isV1UpgradedOrV2(): Promise<boolean>;
    deployMarketplaceModule(metadata: MarketplaceModuleMetadata): Promise<MarketplaceModule>;
}
