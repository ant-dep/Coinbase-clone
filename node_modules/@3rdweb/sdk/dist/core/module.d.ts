import { AccessControlEnumerable } from "@3rdweb/contracts";
import { Log, TransactionReceipt } from "@ethersproject/providers";
import { BaseContract, BytesLike, CallOverrides, ethers, Signer } from "ethers";
import { ModuleType } from "../common/module-type";
import { Role, SetAllRoles } from "../common/role";
import { ISDKOptions } from "../interfaces/ISdkOptions";
import { ModuleMetadata } from "../types/ModuleMetadata";
import { ThirdwebSDK } from "./index";
import type { MetadataURIOrObject, ProviderOrSigner } from "./types";
/**
 * The root Module class. All other Modules extend this.
 * @remarks This should never be instantiated directly.
 * @public
 */
export declare class Module<TContract extends BaseContract = BaseContract> {
    /**
     * @readonly
     */
    readonly address: string;
    /**
     * @internal
     * @readonly
     */
    protected readonly ipfsGatewayUrl: string;
    /**
     * @internal
     * @readonly
     */
    protected readonly options: ISDKOptions;
    protected readonly sdk: ThirdwebSDK;
    /**
     * @internal
     */
    private _providerOrSigner;
    /**
     * @internal
     */
    protected get providerOrSigner(): ProviderOrSigner;
    private set providerOrSigner(value);
    /**
     * @internal
     */
    private _signer;
    /**
     * @internal
     */
    protected get signer(): Signer | null;
    private set signer(value);
    /**
     * Contract connects to the SDK signer or provider
     * @internal
     */
    contract: TContract;
    /**
     * Contract connects to the {@link ISDKOptions.readOnlyRpcUrl} if provided, otherwise connect to signer or provider
     * @internal
     */
    readOnlyContract: TContract;
    /**
     * @internal
     */
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    /**
     * @public
     * @returns whether the given contract exists on-chain
     */
    exists(): Promise<boolean>;
    /**
     * @public
     * Get the metadata of the contract.
     *
     * @param resolveUrls - Whether to resolve the urls in the metadata to a gateway.
     */
    getMetadata(resolveUrls?: boolean): Promise<ModuleMetadata>;
    /**
     * @public
     * Set new metadata on the contract and return it if successful.
     * @param metadata - The metadata to set.
     */
    setMetadata(metadata: MetadataURIOrObject): Promise<ModuleMetadata>;
    /**
     * @internal
     */
    setProviderOrSigner(providerOrSigner: ProviderOrSigner): void;
    /**
     * @internal
     */
    clearSigner(): void;
    /**
     * @internal
     */
    private getProviderOrSigner;
    /**
     * @internal
     */
    protected getSigner(): Signer | null;
    /**
     * @internal
     */
    protected hasValidSigner(): boolean;
    /**
     * @internal
     */
    protected getSignerAddress(): Promise<string>;
    /**
     * @internal
     */
    protected getProvider(): Promise<ethers.providers.Provider>;
    /**
     * @internal
     */
    protected getChainID(): Promise<number>;
    /**
     * @virtual
     * @internal
     */
    protected connectContract(): TContract;
    /**
     * @virtual
     * @internal
     */
    protected getModuleType(): ModuleType;
    /**
     * @internal
     */
    protected getCallOverrides(): Promise<CallOverrides>;
    /**
     * @internal
     */
    private emitTransactionEvent;
    /**
     * @internal
     */
    protected sendTransaction(fn: string, args: any[], callOverrides?: CallOverrides): Promise<TransactionReceipt>;
    /**
     * @internal
     */
    protected sendContractTransaction(contract: BaseContract, fn: string, args: any[], callOverrides?: CallOverrides): Promise<TransactionReceipt>;
    /**
     * @internal
     */
    private sendTransactionByFunction;
    /**
     * @internal
     */
    private sendGaslessTransaction;
    protected signTypedData(signer: ethers.Signer, from: string, domain: {
        name: string;
        version: string;
        chainId: number;
        verifyingContract: string;
    }, types: any, message: any): Promise<BytesLike>;
    protected parseEventLogs(eventName: string, logs?: Log[]): any;
    protected parseLogs<T = any>(eventName: string, logs?: Log[], contract?: BaseContract): T[];
}
/**
 * Extends the {@link Module} class to add {@link Role} functionality.
 *
 * @public
 */
export declare class ModuleWithRoles<TContract extends AccessControlEnumerable = AccessControlEnumerable> extends Module<TContract> {
    /**
     * @virtual
     * @internal
     */
    protected getModuleRoles(): readonly Role[];
    /**
     * @internal
     */
    private get roles();
    /** @internal */
    constructor(providerOrSigner: ProviderOrSigner, address: string, options: ISDKOptions, sdk: ThirdwebSDK);
    /**
     * Call this to get a list of addresses that are members of a specific role.
     *
     * @param role - The {@link IRoles | role} to to get a memberlist for.
     * @returns The list of addresses that are members of the specific role.
     * @throws If you are requestiong a role that does not exist on the module this will throw an {@link InvariantError}.
     * @see {@link ModuleWithRoles.getAllRoleMembers | getAllRoleMembers} to get get a list of addresses for all supported roles on the module.
     * @example Say you want to get the list of addresses that are members of the {@link IRoles.minter | minter} role.
     * ```typescript
     * const minterAddresses: string[] = await module.getRoleMemberList("minter");
     * ```
     *
     * @public
     */
    getRoleMembers(role: Role): Promise<string[]>;
    /**
     * Call this to get get a list of addresses for all supported roles on the module.
     *
     * @see {@link ModuleWithRoles.getRoleMembers | getRoleMembers} to get a list of addresses that are members of a specific role.
     * @returns A record of {@link Role}s to lists of addresses that are members of the given role.
     * @throws If the module does not support roles this will throw an {@link InvariantError}.
     *
     * @public
     */
    getAllRoleMembers(): Promise<Partial<Record<Role, string[]>>>;
    /**
     * Call this to OVERWRITE the list of addresses that are members of specific roles.
     *
     * Every role in the list will be overwritten with the new list of addresses provided with them.
     * If you want to add or remove addresses for a single address use {@link ModuleWithRoles.grantRole | grantRole} and {@link ModuleWithRoles.grantRole | revokeRole} respectively instead.
     * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.
     * @throws If you are requestiong a role that does not exist on the module this will throw an {@link InvariantError}.
     * @example Say you want to overwrite the list of addresses that are members of the {@link IRoles.minter | minter} role.
     * ```typescript
     * const minterAddresses: string[] = await module.getRoleMemberList("minter");
     * await module.setAllRoleMembers({
     *  minter: []
     * });
     * console.log(await module.getRoleMemberList("minter")); // No matter what members had the role before, the new list will be set to []
     * ```
     * @public
     *
     * */
    setAllRoleMembers(rolesWithAddresses: SetAllRoles): Promise<any>;
    /**
     *
     * Call this to revoke all roles given to a specific address.
     * @param address - The address to revoke all roles for.
     * @returns A list of roles that were revoked.
     *
     * @public
     *
     */
    revokeAllRolesFromAddress(address: string): Promise<Role[]>;
    /**
     * Call this to grant a role to a specific address.
     *
     * @remarks
     *
     * Make sure you are sure you want to grant the role to the address.
     *
     * @param role - The {@link IRoles | role} to grant to the address
     * @param address - The address to grant the role to
     * @returns The transaction receipt
     * @throws If you are trying to grant does not exist on the module this will throw an {@link InvariantError}.
     *
     * @public
     */
    grantRole(role: Role, address: string): Promise<TransactionReceipt>;
    /**
     * Call this to revoke a role from a specific address.
     *
     * @remarks
     *
     * -- Caution --
     *
     * This will let you remove yourself from the role, too.
     * If you remove yourself from the {@link IRoles.admin | admin} role, you will no longer be able to administer the module.
     * There is no way to recover from this.
     *
     * @param role - The {@link IRoles | role} to revoke
     * @param address - The address to revoke the role from
     * @returns The transaction receipt
     * @throws If you are trying to revoke does not exist on the module this will throw an {@link InvariantError}.
     *
     * @public
     */
    revokeRole(role: Role, address: string): Promise<TransactionReceipt>;
    private getRevokeRoleFunctionName;
    /**
     * Prepares any set of metadata for uploading by recursively converting all Buffer|Blob|File objects
     * into a hash of the object after its been uploaded to distributed storage (e.g. IPFS). After uploading
     * any File|Buffer|Blob, the metadata is serialized to a string.
     *
     * @param metadata - The list of metadata to prepare for upload.
     * @returns - The serialized metadata object.
     */
    prepareMetadata(metadata: MetadataURIOrObject): Promise<string>;
    /**
     * Prepares a list of metadata for uploading.
     *
     * @param metadata - List of metadata to prepare for upload.
     * @returns - List of metadata prepared for upload.
     */
    prepareBatchMetadata(metadata: MetadataURIOrObject[]): Promise<string[]>;
    /**
     * Throws an error if an address is missing the roles specified.
     *
     * @param roles - The roles to check
     * @param address - The address to check
     */
    protected onlyRoles(roles: Role[], address: string): Promise<void>;
}
