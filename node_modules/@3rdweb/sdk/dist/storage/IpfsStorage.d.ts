/// <reference types="node" />
import { MetadataURIOrObject } from "../core/types";
import { IStorage, UploadMetadataBatchResult } from "../interfaces/IStorage";
import FileOrBuffer from "../types/FileOrBuffer";
import { BufferOrStringWithName } from "../types/BufferOrStringWithName";
export declare class IpfsStorage implements IStorage {
    private gatewayUrl;
    constructor(gatewayUrl: string);
    upload(data: string | FileOrBuffer, contractAddress?: string, signerAddress?: string): Promise<string>;
    uploadBatch(files: Buffer[] | string[] | FileOrBuffer[] | File[] | BufferOrStringWithName[], contractAddress?: string, fileStartNumber?: number): Promise<string>;
    private uploadBatchWithCid;
    getUploadToken(contractAddress: string): Promise<string>;
    get(hash: string): Promise<string>;
    /**
     * This function recurisely traverses an object and hashes any
     * `Buffer` or `File` objects into the returned map.
     *
     * @param object - The object to recurse over
     * @param files - The running array of files or buffer to upload
     * @returns - The final map of all hashes to files
     */
    buildFilePropertiesMap(object: Record<string, any>, files: (File | Buffer)[]): (File | Buffer)[];
    /**
     * Pre-processes metadata and uploads all file properties
     * to storage in *bulk*, then performs a string replacement of
     * all file properties -> the resulting ipfs uri. This is
     * called internally by `uploadMetadataBatch`.
     *
     * @internal
     *
     * @param metadata - The metadata to recursively process
     * @returns - The processed metadata with properties pointing at ipfs in place of `File | Buffer`
     */
    batchUploadProperties(metadatas: MetadataURIOrObject[]): Promise<any>;
    /**
     * Given a map of file hashes to ipfs uris, this function will hash
     * all properties recursively and replace them with the ipfs uris
     * from the map passed in. If a hash is missing from the map, the function
     * will throw an error.
     *
     * @internal
     *
     * @param object - The object to recursively process
     * @param cids - The array of file hashes to ipfs uris in the recurse order
     * @returns - The processed metadata with properties pointing at ipfs in place of `File | Buffer`
     */
    private replaceFilePropertiesWithHashes;
    uploadMetadata(metadata: MetadataURIOrObject, contractAddress?: string, _signerAddress?: string): Promise<string>;
    /**
     * @internal
     */
    uploadMetadataBatch(metadatas: MetadataURIOrObject[], contractAddress?: string, startFileNumber?: number): Promise<UploadMetadataBatchResult>;
    /**
     * Resolves the full url for a file using the configured gateway
     *
     * @param ipfsHash - the ipfs:// uri
     * @returns - The fully formed IPFS url with the gateway url
     * @internal
     */
    resolveFullUrl(ipfsHash: string): string;
}
